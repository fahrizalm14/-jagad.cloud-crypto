/**
 * secure-crypto public API
 * Functions:
 * - ensureDeviceKey(): make or read a per-device random secret stored in indexedDB (non-exportable)
 * - deriveKeyFromPassword(password, salt): derives an AES-GCM 256-bit CryptoKey from password + salt + deviceKey using PBKDF2
 * - generateKeyPair(): creates an RSA-OAEP keypair (for encryption) and returns Exported publicKey (spki) and privateKey (pkcs8)
 * - encryptPrivateKey(privateKeyCryptoKey, derivedKey): encrypts exported privateKey (pkcs8) with AES-GCM derivedKey
 * - decryptPrivateKey(encryptedPackage, derivedKey): decrypts and imports private key
 */

import { idbGet, idbPut } from "./indexeddb";
import { base64ToBuf, bufToBase64 } from "./utils";

const DEVICE_KEY_ID = "device_key_v1";
const DEVICE_KEY_BYTES = 32; // 256-bit

/**
 * Create or return a stored per-device secret (raw bytes) in IndexedDB.
 * We keep the raw bytes in IDB (not in JS memory only) because deviceKey is used as additional salt.
 * Security note: storing raw randomly-generated bytes in IndexedDB is acceptable for device-local entropy
 * but do not export this value.
 */
export async function ensureDeviceKey(): Promise<ArrayBuffer> {
  const existing = await idbGet(DEVICE_KEY_ID);
  if (existing) {
    if (typeof existing === "string") return base64ToBuf(existing);
    return existing;
  }
  const buf = crypto.getRandomValues(new Uint8Array(DEVICE_KEY_BYTES)).buffer;
  // store base64 to avoid IDB ArrayBuffer serialization differences
  await idbPut(DEVICE_KEY_ID, bufToBase64(buf));
  return buf;
}

/**
 * Derive AES-GCM 256-bit key from password + salt + deviceKey.
 * - password: string
 * - salt: Uint8Array | string (if string, will be UTF-8 encoded)
 * Returns: CryptoKey usable for encrypt/decrypt (AES-GCM with length 256)
 */
export async function deriveKeyFromPassword(
  password: string,
  salt: ArrayBuffer | string
) {
  // normalize salt to ArrayBuffer
  let saltBuf: ArrayBuffer;

  if (typeof salt === "string") {
    saltBuf = new TextEncoder().encode(salt).buffer as ArrayBuffer;
  } else if (salt instanceof ArrayBuffer) {
    saltBuf = salt;
  } else {
    throw new Error("Invalid salt type");
  }

  const deviceKey = await ensureDeviceKey();

  // Mix salt + deviceKey: concat(salt || random, deviceKey)
  const saltView = new Uint8Array(saltBuf);
  const deviceView = new Uint8Array(deviceKey);
  const mixed = new Uint8Array(saltView.length + deviceView.length);
  mixed.set(saltView, 0);
  mixed.set(deviceView, saltView.length);

  // Import password as raw key material
  const pwUtf8 = new TextEncoder().encode(password);
  const baseKey = await crypto.subtle.importKey(
    "raw",
    pwUtf8,
    { name: "PBKDF2" },
    false,
    ["deriveKey"]
  );

  // PBKDF2 parameters: large iteration count
  const iterations = 200_000; // increase over time as hardware improves
  const hash = "SHA-256";

  const derived = await crypto.subtle.deriveKey(
    { name: "PBKDF2", salt: mixed.buffer, iterations, hash },
    baseKey,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
  return derived; // CryptoKey
}

/**
 * Generate a new asymmetric key pair for the user.
 * We'll use RSA-OAEP (2048 bits, SHA-256) for encryption/transport; you can switch to ECDSA/ECDH if needed.
 * Returns exported publicKey (spki base64) and privateKey CryptoKey (not exported unless encrypted/wrapped)
 */
export async function generateKeyPair() {
  const pair = await crypto.subtle.generateKey(
    {
      name: "RSA-OAEP",
      modulusLength: 2048,
      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
      hash: "SHA-256",
    },
    true, // extractable because we will export private to encrypt it for storage
    ["encrypt", "decrypt"]
  );

  // Export public key (spki) and private key (pkcs8) as base64 strings
  const pub = await crypto.subtle.exportKey("spki", pair.publicKey);
  const priv = await crypto.subtle.exportKey("pkcs8", pair.privateKey);

  return {
    publicKey: bufToBase64(pub),
    privateKeyRaw: priv, // ArrayBuffer - we'll encrypt this with derived key
  };
}

/**
 * Encrypt an exported private key (ArrayBuffer pkcs8) with derived AES-GCM key.
 * Returns an object: { iv: base64, ciphertext: base64, tagLength }
 */
export async function encryptPrivateKey(
  privateKeyPkcs8: ArrayBuffer,
  derivedKey: CryptoKey
) {
  const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit recommended
  const ct = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    derivedKey,
    privateKeyPkcs8
  );
  return {
    iv: bufToBase64(iv.buffer),
    ciphertext: bufToBase64(ct),
    alg: "AES-GCM",
    tagLength: 128,
  };
}

/**
 * Decrypt and import private key. Returns a CryptoKey (privateKey) that can be used by SubtleCrypto.
 * encryptedPackage: { iv, ciphertext }
 */
export async function decryptPrivateKey(
  encryptedPackage: { iv: string; ciphertext: string },
  derivedKey: CryptoKey
) {
  const iv = base64ToBuf(encryptedPackage.iv);
  const ct = base64ToBuf(encryptedPackage.ciphertext);
  const plain = await crypto.subtle.decrypt(
    { name: "AES-GCM", iv: new Uint8Array(iv) },
    derivedKey,
    ct
  );
  // import pkcs8
  const privKey = await crypto.subtle.importKey(
    "pkcs8",
    plain,
    { name: "RSA-OAEP", hash: "SHA-256" },
    true,
    ["decrypt"]
  );
  return privKey;
}
